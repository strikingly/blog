title: 用简单的概念来写代码（一）
date: 2015-09-06 08:18:12
tags:
- react
categories:
- Frontend
- 中文
---

本文是简单写代码系列的第一集。为什么要写这个系列呢？首先我们开发一个产品，本身会有设计、开发、测试、部署、维护等等等一系列的过程，所以其实编码过程并不一定是整个流程的核心，但是“写代码”这儿词比较亲切，于是就是用它来作为开发的代名词了。不少人都觉得有时候写代码会非常的累，但事实上在产品开发的过程中，我们的代码大多数时候只是一个翻译产品设计的过程，因为我们用到高难度代码的机会真的很少。所以让大多数的时间都能够快乐地编码，是件令人兴奋的事。所以 整个系列始终会围绕着如何简单，高效地将实际的产品转化为可读性、可维护性高的代码。将会从最简单的概念开始，一点一点深入。当然，更多的都是个人的一些思考和经验，所以仅供参考。后面几集实例的描述会用 React 作为我们的实战工具。

首先，正式开始之前，我们先来聊聊如何可以简单地来描述一个概念、一样东西、或者一起事件。首先从想法，概念上去变得简单，才会让实践的时候更简单。

通常，我们立即会想到，可以用属性这个概念来描述物体。不同属性的组合便成就了许许多多不同的物体。对于一些稍复杂的物体，更有物体行为这一层概念，但我们也可以简单的把行为看做是一种特殊的、需要更多描述的属性。于是，假如我们拥有一切物体的一切属性，并把这些属性都归到一个巨大的集合中，那么任何一个（一类）物体我们都可以看作是那个巨大集合的子集。于是我们便可用集合论做出更多更好的抽象、管理的工作。面向对象就类似走的这个套路。

现在，我们再近一步想一下。这些属性都仅仅是抽象出来的概念而已，具体到实际显然需要一些实际的值。这时候我们就可以用值或者状态这一概念来把属性给具体化了。因为下文会主要讨论到状态，所以就用状态这个词了。我们可以看到，一旦有了状态，每个具体的物体就像活了一样。对于同一类（有相同属性的）物体，我们也可以根据状态来区分它们。同一个物体在不同时刻，我们也可以根据状态的不同而加以区分，只需要我们抽象出一个和时间有关的属性即可（当然计算机的世界，我们采用经典时空观会比较容易理解）。这么一来，状态和时间属性的引入，瞬间让我们用计算机描述的世界具有了动态性。

既然有了时间的概念，那必然少不了演化的概念。阐述演化之前我们先来做一个约定：为了简单起见，物体拥有哪些属性，在一开始我们就决定好了。于是，演化就可以认为是一个状态随着时间的推进而变化的过程。可能有人会想，在真实世界里，还会有进化这个概念，当然程序中我们也可以把我们人为去更新代码作为一个类比。但我们先撇开这个，如果只讨论同样代码下的执行和使用过程，那么演化的定义依旧可以去那么认为。此时，其实我们就会很自然的有一个状态机的概念了。它是我们描述世界的一个重要手段。还记得上文提到过物体行为这个概念么？当时把它作为一个复杂的物体属性来看，其实我们还可以把行为看做是一个描述状态该如何变化过程，那就是一个事件。假如我们有了某个描述状态如何变化的过程，那么，事件到底用只是指代那个过程好呢还是直接表示那个过程本身好？这是个问题，但为了方便阐释，认为是后者先。当然，其实不管把事件理解成什么，似乎并不影响结果，因为语言（写此文的语言）本身在这也只是起了指代概念的作用。

好了，先简单总结下之前提到的几个概念：属性、状态、事件。他们之间简单的关系就是：每个物体都有许多属性，每个属性都有一系列的状态，事件的发生会让某个或某些属性产生变化，而事件本身也描述了状态该如何改变。

当然，为了更清晰的描述，可以把一部分特殊事件从事件中拆分出来。那些特殊事件可以简单称作触发器。假设物体的每增加一个事件描述，就会多一个该事件的开关的属性和与之对应的触发器事件。开关只描述事件要不要去发生。触发器则只控制开关的状态，开或者关。这样，本来用描述其他状态如何变化的信息可以完全剥离出来，成为了更纯粹的事件，不需要外界去触发这个纯粹事件，外界要做的，仅仅是去调用触发器。如果我们把触发器看做是物体和外界之间的联系而非属于物体本身的话，我们完全可以用某个属性来表示事件是否发生。这样，在描述一个物体的时候（类，组件等），我们只需要给出属性和事件的定义即可。特别地，若是我们要求某个物体的属性状态只能被内部改变的话，就可以很纯粹地封装出我们需要的组件。

那样一来，我们的代码其实就干了三件描述性的事：属性、事件和环境。至于环境，可以当做一个更高层次的物体，物体本身可以嵌套物体。于是环境也可以分解成属性和事件。其实，还剩下一些辅助性的代码，比如许许多多辅助函数。但我们可以用同样的思路转化它。因为某些属性我们可以读写，这其实就已经解决了我们的问题，输入和输出。如果我们把输入输出看做是某个带有计算功能的物体的两个属性，那么我们只需要给定输入的状态，然后触发计算事件，物体内部自动会把计算结果更新到输出属性中，最后再读取输出属性即可。虽然这画蛇添足，实际过程中一般不会去那么傻傻地做，但只是为了说明仅用属性和事件是可以描述几乎一切东西的。尤其是对于 UI 来说，纯碎的属性和事件确实能够简洁地描述出一款产品的流程体验。CSS 的语法就是一个很好的例子，虽然只有属性部分，但语言本身绝对简洁，一目了然（复杂性带来的架构上的问题不属于这里讨论的范围）。Facebook 出品的 React 就提供了这么一个描述 UI 的方式，非常方便和简洁。另外一个非常大的好处就是极大地方便了测试。因为我们只有属性和事件需要测试，而事件只是描述属性变化的东西，那么我们需要做的只是给定任一一个具体的状态集，同时隔离外界的影响，看结果是不是符合我们的预期就行了。对于复杂的测试，只需要外界可控地触发开关事件，一步步记录结果是否正确即可。

但还有一个问题，那就是这一切都只是个理想的状态，不过实际情况总的来说还算是理想。因为我们的代码几乎是在一个封闭的环境中执行的。如果不算网络通信和用户事件的话，在单机情况下，确实是封闭的。即使加上网络通信，我们把应用程序的范围扩大一点，服务端和客户端的代码都加上，其实还是一个类似封闭的环境（不考虑硬件问题）。只要是这样的环境，那一切都是可控的，我们的代码早已描述好了一切，剩下的就是在初始状态给定的条件下自发地进行演变，同时不断地接受事件的触发（用户事件的反馈早已在代码中描述好了）。

虽然很简单，却又很基础。因为复杂性的提升后，必然会带来整个软件产品架构上的一些问题，比如组件间的数据交换，远程的数据通信，第三方插件的整合等等。还包括一些设计上的比如组件之间的关系，属性和事件的确定与规范等等。幸好，每个组件本身都是小而美的，基本都可以按照这个想法构建出来。所以整个方案依然具有一定的实践指导意义。

本集暂时先给出这个纯语言上的描述方案，在下一集中，将结合 ReactJs 具体给出一个实例来说明如何践行“属性加事件”这一编码理念，重在设计，其次才是编码。
